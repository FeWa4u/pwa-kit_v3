/*
 * Copyright (c) 2023, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import {UseQueryResult} from '@tanstack/react-query'
import {ApiClients, ApiQueryOptions, Argument, DataType} from '../types'
import useCommerceApi from '../useCommerceApi'
import {useQuery} from '../useQuery'
import {mergeOptions, pick} from '../utils'

{{!~-- Add aliases to @root for brevity/clarity --~}}
{{~ assign 'clientInstance' name.lowerCamelCase ~}}
{{~ assign 'clientClass' name.upperCamelCase ~}}

type Client = ApiClients['{{@root.clientInstance}}']

{{#each model.encodes.endPoints}}{{#each operations}}{{#if (isQuery @root.clientClass this)~}}
/**
 * A hook for `{{@root.clientClass}}#{{name}}`.
 * {{{formatForTsDoc description}}}
 * @see {@link https://developer.salesforce.com/docs/commerce/commerce-api/references/{{@root.name.kebabCase}}?meta={{name~}} } for more information about the API endpoint.
 * @see {@link https://salesforcecommercecloud.github.io/commerce-sdk-isomorphic/classes/{{lowercase @root.clientInstance}}.{{lowercase @root.clientInstance}}-1.html#{{lowercase (getValue name)~}} } for more information on the parameters and returned data type.
 * @returns An object describing the state of the request.
 */
export const use{{#startsWith 'get' (getValue name)~}}
{{removeFirst (getValue name) 'get'}}
{{~else~}}
{{~#startsWith 'retrieve' (getValue name)~}}
{{removeFirst (getValue name) 'retrieve'}}
{{~else~}}
{{capitalize (getValue name)}}
{{~/startsWith}}{{/startsWith}} = (
    apiOptions: Argument<Client['{{name}}']>,
    queryOptions: ApiQueryOptions<Client['{{name}}']> = {}
): UseQueryResult<DataType<Client['{{name}}']>> => {
    type Options = Argument<Client['{{name}}']>
    type Data = DataType<Client['{{name}}']>
    const { {{~@root.clientInstance}}: client} = useCommerceApi()
    const method = async (options: Options) => await client.{{name}}(options)
    const requiredParameters = [
        {{#each ../parameters}}
        '{{name}}',
        {{/each~}}
        {{~#each request.queryParameters}}
        {{#if (is required "true")}}'{{name}}',{{/if}}
        {{/each}}
    ] as const
    const allParameters = [
        ...requiredParameters,
        {{~#each request.queryParameters}}
        {{#unless (is required "true")}}'{{name}}',{{/unless}}
        {{/each}}
    ] as const
    // Parameters can be set in `apiOptions` or `client.clientConfig`, we must merge them in order
    // to generate the correct query key.
    const netOptions = mergeOptions(client, apiOptions)
    // `client.clientConfig` can have parameters that are not relevant to this endpoint, so we must
    // exclude them when generating the query key.
    const parameters = pick(netOptions.parameters, allParameters)
    const queryKey = [
        {{{createQueryKeyFragment (getValue ../path) 'parameters'}}},
        parameters
    ] as const
    
    // For some reason, if we don't explicitly set these generic parameters, the inferred type for
    // `Data` sometimes, but not always, includes `Response`, which is incorrect. I don't know why.
    return useQuery<Options, Data>(
        netOptions,
        {{#if (is method 'get')}}queryOptions,
        {{~else~}}
        {
            // !!! This is a violation of our design goal of minimal logic in the indivudal endpoint
            // endpoint hooks. This is because this method is a {{method}} method, rather than GET,
            // and its body contains secrets. Setting cacheTime to 0 avoids exposing the secrets in
            // the shared cache.
            cacheTime: 0,
            ...queryOptions
        },{{/if}}
        {
            method,
            queryKey,
            requiredParameters
        }
    )
}
{{/if}}{{/each}}{{/each}}
